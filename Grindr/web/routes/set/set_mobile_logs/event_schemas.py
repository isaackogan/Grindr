import abc
import json
import random
from typing import Literal, Type, ClassVar, Union, Any

from pydantic import BaseModel, PrivateAttr, Field, model_validator, ValidationError

from Grindr.web.web_settings import LATEST_APP, BUILD_NUMBER

"""
DISCLAIMER:

Types generated by ChatGPT 4o. A human was not involved in (most of) the making of this file.
I only briefly looked over it for sanity's sake & checked the types against some raw data in test directory.

"""


class _EventMap(dict):
    """A mapping of event names to their corresponding event classes"""

    @property
    def json_types(self) -> Type:
        # Create a union of all Json[Event] types
        return Union[tuple(self.values())]

    @property
    def event_names(self) -> Type:
        # Get the keys as a list of strings
        keys = list(self.keys())

        # Create a dynamic Union of Literal types using type hints
        return Union[tuple(Literal[key] for key in keys)]


EventMap: _EventMap = _EventMap()


class BaseLogEventData(abc.ABC, BaseModel):
    """A Log Event"""

    # A class var representing the event name
    _event_name: ClassVar[str] = PrivateAttr()

    is_background: bool = False
    version_code: int = int(BUILD_NUMBER)

    @property
    def event_name(self) -> str:
        return self._event_name


type LogFilter = dict[Literal["online_now", "not_recently_chatted"], bool]


# noinspection PyPep8Naming
def LogEvent[T](name: str):
    """Wrap an event payload as an event"""

    def decorator(cls: T) -> object:
        cls._event_name = name

        # This way subclasses don't override the base class
        if name not in EventMap:
            EventMap[name] = cls

        return cls

    return decorator


@LogEvent("chat_received")
class ChatReceivedLogData(BaseLogEventData):
    time_passed_since_last_seen: int
    last_seen: int
    source: str
    type: Literal["Text", "Image"] | str
    push_notification: bool
    boost: bool
    pii_target_profile_id: str | None = None
    pii_message_id: str | None = None


@LogEvent("websocket_event")
class WebSocketEventLogData(BaseLogEventData):
    session_id: int = 0  # Auto-incrementing persistent ID representing the N'th time connecting to the WS (for this device? in total? idk.)
    event_id: int = 0  # Again, auto-incrementing, but within the current WebSocket connection. Starts at 0.
    event_type: Literal["Error", "Connecting", "Connected", "Closed"] | str

    # Only provided when event_type is "Error"
    error_type: str | None = None

    # Only provided when event_type is "Closed"
    code: int | None = None
    message: str | None = None

    def model_dump(
            self,
            **kwargs
    ) -> dict[str, Any]:
        kwargs['exclude_none'] = True
        return super().model_dump(**kwargs)


@LogEvent("page")
class PageLogData(BaseLogEventData):
    page_name: str
    type: Literal["start", "stop"] | str


@LogEvent("subscription_status_changed")
class SubscriptionStatusChangedLogData(BaseLogEventData):
    subscription_status_changed_to: Literal["FREE", "PREMIUM"] | str


@LogEvent("location_first_request_time")
class LocationFirstRequestTimeLogData(BaseLogEventData):
    time: int


@LogEvent("assignment_load_called")
class AssignmentLoadCalledLogData(BaseLogEventData):
    pass  # No additional fields in the provided data


@LogEvent("cascade_session_start")
class CascadeSessionStartLogData(BaseLogEventData):
    cascade_session_id: str
    cascade_type: str
    request_type: Literal["manual"] | str
    filters: str
    fresh: bool
    tags: list[str]


@LogEvent("cascade_session_end")
class CascadeSessionEndLogData(BaseLogEventData):
    cascade_session_id: str
    position_in_cascade: int
    max_distance: str


@LogEvent("app_opened")
class AppOpenedLogData(BaseLogEventData):
    distance_setting_enabled: bool
    launch_from_push: bool
    push_enabled: bool
    launch_type: Literal["launch"] | str
    network_status: Literal["WIFI", "MOBILE_DATA"] | str
    api_level: int
    installer_package: str
    old_signature: bool
    pii_advertising_id: str


@LogEvent("noti_settings_update")
class NotiSettingsUpdateLogData(BaseLogEventData):
    show_notification: bool
    general: bool
    tap: bool
    individual_chat: bool
    video_call: bool


@LogEvent("active_user_pageflow")
class ActiveUserPageFlowLogData(BaseLogEventData):
    session_id: str
    pii_profile_id: str
    page: Literal["CASCADE", "INBOX", "CHAT", "PROFILE_PAGE"] | str
    action: Literal["OPEN", "CLOSE"] | str
    is_incognito: bool
    pii_counter_profile_ids: str | None = None  # Despite name seems to be only 1 str, if multiple 'prolly csv


@LogEvent("profile_interaction")
class ProfileInteractionLogData(BaseLogEventData):
    pii_counter_profile_ids: str
    index: int
    has_unread_throb: bool
    pii_no_interaction_profiles: dict[str, str]


@LogEvent("interest_screen_viewed")
class InterestScreenViewedLogData(BaseLogEventData):
    time: int = Field(default_factory=lambda: random.randint(20, 40))  # Not unix, e.g. "38" <-- milliseconds since app opened? (definitely this yes)


@LogEvent("chat_screen_viewed")
class ChatScreenViewedLogData(BaseLogEventData):
    referring_screen: str
    prev_referrer: str
    is_group_chat: bool
    has_unread_throb: bool
    boost: bool
    chat_session_id: str
    pii_target_profile_id: str


@LogEvent("cascade_filtered")
class CascadeFilteredLogData(BaseLogEventData):
    filter: str = "online_now_haven't_chatted"
    location: str = "nearby"


@LogEvent("explore_map_viewed")
class ExploreMapViewedLogData(BaseLogEventData):
    subscription_status: Literal["FREE", "PREMIUM"] | str


@LogEvent("enable_location_result")
class EnableLocationResultLogData(BaseLogEventData):
    result: Literal["allowed", "denied"] | str


@LogEvent("cascade_screen_viewed")
class CascadeScreenViewedLogData(BaseLogEventData):
    pass  # No additional fields in the provided data


@LogEvent("first_open")
class FirstOpenLogData(BaseLogEventData):
    pass  # No additional fields in the provided data


@LogEvent("chat_close")
class ChatCloseLogData(BaseLogEventData):
    chat_session_id: str
    chat_session_length: int
    referring_screen: str
    previous_referring_screen: str
    chat_sent_count: int


@LogEvent("screenshot_obs_noperm")
class ScreenshotObsNoPermLogData(BaseLogEventData):
    pass  # No additional fields in the provided data


@LogEvent("applovin_init_result")
class ApplovinInitResultLogData(BaseLogEventData):
    result: Literal["Success", "Failure"] | str


@LogEvent("assignment_log_exposure_called")
class AssignmentLogExposureCalledLogData(BaseLogEventData):
    key: str


@LogEvent("assignment_log_exposure_success")
class AssignmentLogExposureSuccessLogData(BaseLogEventData):
    key: str


@LogEvent("setting_keepPhoneAwake")
class SettingKeepPhoneAwakeLogData(BaseLogEventData):
    setting_keepPhoneAwake_result: bool


@LogEvent("drawer_profile_screen_viewed")
class DrawerProfileScreenViewedLogData(BaseLogEventData):
    pass  # No additional fields in the provided data


@LogEvent("drawer_profile_edit_profile_clicked")
class DrawerProfileEditProfileClickedLogData(BaseLogEventData):
    pass  # No additional fields in the provided data


@LogEvent("edit_profile_viewed")
class EditProfileViewedLogData(BaseLogEventData):
    pass  # No additional fields in the provided data


@LogEvent("my_albums_viewed")
class MyAlbumsViewedLogData(BaseLogEventData):
    source: str


@LogEvent("view_profile_from_drawer")
class ViewProfileFromDrawerLogData(BaseLogEventData):
    pass  # No additional fields in the provided data


@LogEvent("drawer_profile_thumbnail_clicked")
class DrawerProfileThumbnailClickedLogData(BaseLogEventData):
    pass  # No additional fields in the provided data


@LogEvent("drawer_profile_settings_clicked")
class DrawerProfileSettingsClickedLogData(BaseLogEventData):
    pass  # No additional fields in the provided data


@LogEvent("cascade_explore_screen_time_on_screen")
class CascadeExploreScreenTimeOnScreenLogData(BaseLogEventData):
    explore_time_spent: int


@LogEvent("profile_quickbar_closed")
class ProfileQuickbarClosedLogData(BaseLogEventData):
    pass  # No additional fields in the provided data


@LogEvent("profile_own_viewed")
class ProfileOwnViewedLogData(BaseLogEventData):
    target_profile_type: str
    referring_screen: str
    position_in_cascade: int
    current_cascade_size: int


@LogEvent("settings_viewed")
class SettingsViewedLogData(BaseLogEventData):
    pass  # No additional fields in the provided data


@LogEvent("session_start")
class SessionStartLogData(BaseLogEventData):
    session_id: str


@LogEvent("session_end")
class SessionEndLogData(BaseLogEventData):
    duration: int


@LogEvent("rating_banner_shown")
class RatingBannerShownLogData(BaseLogEventData):
    type: str = "viewed_me_threshold"


@LogEvent("login_successful")
class LoginSuccessfulLogData(BaseLogEventData):
    source: str = "email"
    page: str = "LoginActivity"
    pii_advertising_id: str = "00000000-0000-0000-0000-000000000000"
    email: str


@LogEvent("inbox_screen_viewed")
class InboxScreenViewedLogData(BaseLogEventData):
    pass


@LogEvent("inbox_messages_viewed")
class InboxMessagesViewedLogData(BaseLogEventData):
    pass


@LogEvent("view_profile_from_notification")
class ViewProfileFromNotificationLogData(BaseLogEventData):
    pass


@LogEvent("profile_viewed")
class ProfileViewedLogData(BaseLogEventData):
    target_is_online: bool
    is_favorite: bool
    is_new: bool
    filter: str
    target_profile_type: str
    referring_screen: str
    pii_target_profile_id: str  # Typically a string for IDs
    position_in_cascade: int
    current_cascade_size: int


@LogEvent("assignment_load_success")
class AssignmentLoadSuccessLogData(BaseLogEventData):
    pass


@LogEvent("viewed_me_list_viewed")
class ViewedMeListViewedLogData(BaseLogEventData):
    source: str = "from_radar"


@LogEvent("viewed_me_list_refreshed")
class ViewedMeListRefreshedLogData(BaseLogEventData):
    type: str = "auto"


@LogEvent("viewed_me_profile_clicked")
class ViewedMeProfileClickedLogData(BaseLogEventData):
    type: str = "normal"
    visible: bool = False
    boost: bool = False


@LogEvent("view_profile_from_viewed_me")
class ViewedMeProfileViewedMeLogData(BaseLogEventData):
    pass


@LogEvent("multiphoto_profile_viewed")
class MultiphotoProfileViewedLogData(BaseLogEventData):
    pass


@LogEvent("viewed_me_list_left")
class ViewedMeListLeftLogData(BaseLogEventData):
    type: str = "auto"
    total: int = 100  # No. of profiles

    # Categorization of type of viewer
    normal: int = 95
    favorite: int = 5
    fresh_face: int = 0
    secret_admirer: int = 0


@LogEvent("profile_extended_viewed")
class ProfileExtendedViewLogData(BaseLogEventData):
    pass


@LogEvent("home_drawer_closed")
class HomeDrawerClosedLogData(BaseLogEventData):
    drawer: str = "e"
    open_by: str = "drag"
    do_nothing: bool = False
    version_code: str = LATEST_APP + "." + BUILD_NUMBER


@LogEvent("favorites_tab_viewed")
class FavoritesTabViewedLogData(BaseLogEventData):
    pass


@LogEvent("favorites_screen_viewed")
class FavoritesScreenViewedLogData(BaseLogEventData):
    pass


class MobileLogEvent[T: EventMap.event_names, Z: EventMap.json_types](BaseModel):
    """A mobile log event sent to the Grindr API"""

    id: int
    name: T = Field(union_mode='left_to_right')
    timestamp: int
    params: Z = Field(union_mode='left_to_right')

    def __init__(self, /, **data: Any):
        name = data.get('name', None)

        if EventMap.get(name) is None:
            raise ValueError(f"Missing event name \"{name}\" in MobileLogEvent schema definition!")

        params_type_name = EventMap.get(name).__name__

        try:
            super().__init__(**data)
        except ValidationError as ex:
            ex.add_note(f"Variant: MobileLogEvent[\"{name}\", {params_type_name}]")
            raise ex

    # Custom validation for `params` field
    # noinspection PyMethodParameters
    @model_validator(mode="before")
    def parse_params(cls, values):

        # If not a dict, skip this (e.g. in a union)
        if not isinstance(values, dict):
            return values

        name = values.get("name")
        params = values.get("params")

        # Get the expected model type
        expected_model = EventMap.get(name)
        if not expected_model:
            raise ValueError(f"Unknown event name: {name}")

        # Handle a string
        if isinstance(params, str):
            try:
                parsed_params = json.loads(params)
            except json.JSONDecodeError:
                raise ValueError(f"Invalid JSON string for params: {params}")
            values["params"] = expected_model(**parsed_params)

        # Handle a dict
        elif isinstance(params, dict):
            # Validate params as a dictionary
            values["params"] = expected_model(**params)

        return values

    # Custom JSON serialization for `params`
    def model_dump(self, **kwargs):
        data = super().model_dump(**kwargs)
        data["params"] = self.params.model_dump_json(**kwargs) if self.params else None
        return data

    def model_dump_json(self, **kwargs) -> str:
        original_kwargs = kwargs.copy()

        # Exclude the params from the JSON dump
        exclude = set(kwargs.pop("exclude", set()))  # Exclude the params
        exclude.add("params")
        kwargs["exclude"] = exclude

        # Dump & reload, add params
        data: dict = json.loads(super().model_dump_json(**original_kwargs))
        data["params"] = self.params.model_dump_json() if self.params else None

        # Return the JSON string
        return json.dumps(data)
